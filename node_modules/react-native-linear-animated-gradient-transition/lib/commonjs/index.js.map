{"version":3,"sources":["index.tsx"],"names":["AnimatedGradientTransition","Component","constructor","props","state","colors","prevColors","animatedColors","map","Animated","Value","getDerivedStateFromProps","nextProps","prevState","keys","mutableProps","_","pick","stateToCompare","animateGradientTransition","animation","defaultProps","isEqual","curColors","length","forEach","animatedColor","setValue","parallel","timing","toValue","duration","easing","useNativeDriver","start","_getColorSafely","index","slice","_getInterpolatedColors","end","interpolate","inputRange","outputRange","_generateColorsProps","interpolatedColors","interpolateColor","key","merge","render","children","animatedColorsProps","otherProps","omit","Easing","linear"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { Easing, Animated } from 'react-native';\nimport _ from 'lodash';\nimport AnimatedLinearGradient from './AnimatedLinearGradient';\nimport type { LinearGradientProps } from 'react-native-linear-gradient';\n\nexport interface IProps extends LinearGradientProps {\n  animation?: Animated.TimingAnimationConfig;\n}\n\ninterface IState {\n  colors: (string | number)[];\n  prevColors: (string | number)[];\n  animatedColors: Animated.Value[];\n}\n\nclass AnimatedGradientTransition extends Component<IProps, IState> {\n  static defaultProps = {\n    colors: ['#fff', '#fff'],\n    animation: {\n      toValue: 1,\n      duration: 500,\n      easing: Easing.linear,\n      useNativeDriver: false,\n    },\n  };\n\n  constructor(props: IProps) {\n    super(props);\n\n    this.state = {\n      colors: props.colors,\n      prevColors: props.colors,\n      animatedColors: props.colors.map(() => new Animated.Value(0)),\n    };\n  }\n\n  static getDerivedStateFromProps(nextProps: IProps, prevState: IState) {\n    const keys = ['colors'];\n    const mutableProps = _.pick(nextProps, keys);\n    const stateToCompare = _.pick(prevState, keys);\n    let animatedColors = prevState.animatedColors;\n\n    animatedColors = AnimatedGradientTransition.animateGradientTransition(\n      animatedColors,\n      mutableProps.colors,\n      prevState.colors,\n      (nextProps.animation = AnimatedGradientTransition.defaultProps.animation)\n    );\n\n    if (!_.isEqual(mutableProps, stateToCompare)) {\n      return {\n        ...mutableProps,\n        animatedColors,\n        prevColors: prevState.colors,\n      };\n    }\n\n    return null;\n  }\n\n  static animateGradientTransition(\n    animatedColors: Animated.Value[],\n    curColors: (string | number)[] | undefined,\n    prevColors: (string | number)[],\n    animation: Animated.TimingAnimationConfig\n  ) {\n    // Animate only if the new colors are different\n    if (!_.isEqual(prevColors, curColors)) {\n      // Update number of animatedValue if the length is different\n      if (curColors && animatedColors.length !== curColors.length) {\n        animatedColors = curColors.map(() => new Animated.Value(0));\n      } else {\n        animatedColors.forEach((animatedColor) => animatedColor.setValue(0));\n      }\n\n      // Parallel animation of all background colors\n      Animated.parallel(\n        animatedColors.map((animatedColor) => {\n          return Animated.timing(animatedColor, {\n            toValue: animation.toValue,\n            duration: animation.duration,\n            easing: animation.easing,\n            useNativeDriver: false,\n          });\n        })\n      ).start();\n    }\n\n    return animatedColors;\n  }\n\n  _getColorSafely(colors: (string | number)[], index: number) {\n    if (colors[index]) {\n      return colors[index];\n    }\n\n    return colors.slice(-1)[0];\n  }\n\n  _getInterpolatedColors() {\n    const { colors, prevColors, animatedColors } = this.state;\n\n    return animatedColors.map((animatedColor, index) => {\n      const start = this._getColorSafely(prevColors, index);\n      const end = this._getColorSafely(colors, index);\n      if (typeof start === 'string' && typeof end === 'string') {\n        return animatedColor.interpolate({\n          inputRange: [0, 1],\n          outputRange: [start, end],\n        });\n      } else if (typeof start === 'number' && typeof end === 'number') {\n        return animatedColor.interpolate({\n          inputRange: [0, 1],\n          outputRange: [start, end],\n        });\n      }\n      return new Animated.Value(0);\n    });\n  }\n\n  // Send all colors as props to enable Animated api to transform it\n  _generateColorsProps(interpolatedColors: Animated.AnimatedInterpolation[]) {\n    let props = {};\n\n    interpolatedColors.forEach((interpolateColor, index) => {\n      const key = `animatedColor${index}`;\n\n      props = _.merge(props, {\n        [key]: interpolateColor,\n      });\n\n      return {\n        [key]: interpolateColor,\n      };\n    });\n\n    return props;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    const interpolatedColors = this._getInterpolatedColors();\n    const animatedColorsProps = this._generateColorsProps(interpolatedColors);\n    const otherProps = _.omit(props, 'animation');\n    return (\n      <AnimatedLinearGradient {...otherProps} {...animatedColorsProps}>\n        <>{children}</>\n      </AnimatedLinearGradient>\n    );\n  }\n}\n\nexport default AnimatedGradientTransition;\n"]}