{"version":3,"sources":["index.tsx"],"names":["React","Component","Easing","Animated","_","AnimatedLinearGradient","AnimatedGradientTransition","constructor","props","state","colors","prevColors","animatedColors","map","Value","getDerivedStateFromProps","nextProps","prevState","keys","mutableProps","pick","stateToCompare","animateGradientTransition","animation","defaultProps","isEqual","curColors","length","forEach","animatedColor","setValue","parallel","timing","toValue","duration","easing","useNativeDriver","start","_getColorSafely","index","slice","_getInterpolatedColors","end","interpolate","inputRange","outputRange","_generateColorsProps","interpolatedColors","interpolateColor","key","merge","render","children","animatedColorsProps","otherProps","omit","linear"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { Easing, Animated } from 'react-native';\nimport _ from 'lodash';\nimport AnimatedLinearGradient from './AnimatedLinearGradient';\nimport type { LinearGradientProps } from 'react-native-linear-gradient';\n\nexport interface IProps extends LinearGradientProps {\n  animation?: Animated.TimingAnimationConfig;\n}\n\ninterface IState {\n  colors: (string | number)[];\n  prevColors: (string | number)[];\n  animatedColors: Animated.Value[];\n}\n\nclass AnimatedGradientTransition extends Component<IProps, IState> {\n  static defaultProps = {\n    colors: ['#fff', '#fff'],\n    animation: {\n      toValue: 1,\n      duration: 500,\n      easing: Easing.linear,\n      useNativeDriver: false,\n    },\n  };\n\n  constructor(props: IProps) {\n    super(props);\n\n    this.state = {\n      colors: props.colors,\n      prevColors: props.colors,\n      animatedColors: props.colors.map(() => new Animated.Value(0)),\n    };\n  }\n\n  static getDerivedStateFromProps(nextProps: IProps, prevState: IState) {\n    const keys = ['colors'];\n    const mutableProps = _.pick(nextProps, keys);\n    const stateToCompare = _.pick(prevState, keys);\n    let animatedColors = prevState.animatedColors;\n\n    animatedColors = AnimatedGradientTransition.animateGradientTransition(\n      animatedColors,\n      mutableProps.colors,\n      prevState.colors,\n      (nextProps.animation = AnimatedGradientTransition.defaultProps.animation)\n    );\n\n    if (!_.isEqual(mutableProps, stateToCompare)) {\n      return {\n        ...mutableProps,\n        animatedColors,\n        prevColors: prevState.colors,\n      };\n    }\n\n    return null;\n  }\n\n  static animateGradientTransition(\n    animatedColors: Animated.Value[],\n    curColors: (string | number)[] | undefined,\n    prevColors: (string | number)[],\n    animation: Animated.TimingAnimationConfig\n  ) {\n    // Animate only if the new colors are different\n    if (!_.isEqual(prevColors, curColors)) {\n      // Update number of animatedValue if the length is different\n      if (curColors && animatedColors.length !== curColors.length) {\n        animatedColors = curColors.map(() => new Animated.Value(0));\n      } else {\n        animatedColors.forEach((animatedColor) => animatedColor.setValue(0));\n      }\n\n      // Parallel animation of all background colors\n      Animated.parallel(\n        animatedColors.map((animatedColor) => {\n          return Animated.timing(animatedColor, {\n            toValue: animation.toValue,\n            duration: animation.duration,\n            easing: animation.easing,\n            useNativeDriver: false,\n          });\n        })\n      ).start();\n    }\n\n    return animatedColors;\n  }\n\n  _getColorSafely(colors: (string | number)[], index: number) {\n    if (colors[index]) {\n      return colors[index];\n    }\n\n    return colors.slice(-1)[0];\n  }\n\n  _getInterpolatedColors() {\n    const { colors, prevColors, animatedColors } = this.state;\n\n    return animatedColors.map((animatedColor, index) => {\n      const start = this._getColorSafely(prevColors, index);\n      const end = this._getColorSafely(colors, index);\n      if (typeof start === 'string' && typeof end === 'string') {\n        return animatedColor.interpolate({\n          inputRange: [0, 1],\n          outputRange: [start, end],\n        });\n      } else if (typeof start === 'number' && typeof end === 'number') {\n        return animatedColor.interpolate({\n          inputRange: [0, 1],\n          outputRange: [start, end],\n        });\n      }\n      return new Animated.Value(0);\n    });\n  }\n\n  // Send all colors as props to enable Animated api to transform it\n  _generateColorsProps(interpolatedColors: Animated.AnimatedInterpolation[]) {\n    let props = {};\n\n    interpolatedColors.forEach((interpolateColor, index) => {\n      const key = `animatedColor${index}`;\n\n      props = _.merge(props, {\n        [key]: interpolateColor,\n      });\n\n      return {\n        [key]: interpolateColor,\n      };\n    });\n\n    return props;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    const interpolatedColors = this._getInterpolatedColors();\n    const animatedColorsProps = this._generateColorsProps(interpolatedColors);\n    const otherProps = _.omit(props, 'animation');\n    return (\n      <AnimatedLinearGradient {...otherProps} {...animatedColorsProps}>\n        <>{children}</>\n      </AnimatedLinearGradient>\n    );\n  }\n}\n\nexport default AnimatedGradientTransition;\n"]}