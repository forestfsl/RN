function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React, { Component } from 'react';
import { Easing, Animated } from 'react-native';
import _ from 'lodash';
import AnimatedLinearGradient from './AnimatedLinearGradient';

class AnimatedGradientTransition extends Component {
  constructor(props) {
    super(props);
    this.state = {
      colors: props.colors,
      prevColors: props.colors,
      animatedColors: props.colors.map(() => new Animated.Value(0))
    };
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    const keys = ['colors'];

    const mutableProps = _.pick(nextProps, keys);

    const stateToCompare = _.pick(prevState, keys);

    let animatedColors = prevState.animatedColors;
    animatedColors = AnimatedGradientTransition.animateGradientTransition(animatedColors, mutableProps.colors, prevState.colors, nextProps.animation = AnimatedGradientTransition.defaultProps.animation);

    if (!_.isEqual(mutableProps, stateToCompare)) {
      return _objectSpread(_objectSpread({}, mutableProps), {}, {
        animatedColors,
        prevColors: prevState.colors
      });
    }

    return null;
  }

  static animateGradientTransition(animatedColors, curColors, prevColors, animation) {
    // Animate only if the new colors are different
    if (!_.isEqual(prevColors, curColors)) {
      // Update number of animatedValue if the length is different
      if (curColors && animatedColors.length !== curColors.length) {
        animatedColors = curColors.map(() => new Animated.Value(0));
      } else {
        animatedColors.forEach(animatedColor => animatedColor.setValue(0));
      } // Parallel animation of all background colors


      Animated.parallel(animatedColors.map(animatedColor => {
        return Animated.timing(animatedColor, {
          toValue: animation.toValue,
          duration: animation.duration,
          easing: animation.easing,
          useNativeDriver: false
        });
      })).start();
    }

    return animatedColors;
  }

  _getColorSafely(colors, index) {
    if (colors[index]) {
      return colors[index];
    }

    return colors.slice(-1)[0];
  }

  _getInterpolatedColors() {
    const {
      colors,
      prevColors,
      animatedColors
    } = this.state;
    return animatedColors.map((animatedColor, index) => {
      const start = this._getColorSafely(prevColors, index);

      const end = this._getColorSafely(colors, index);

      if (typeof start === 'string' && typeof end === 'string') {
        return animatedColor.interpolate({
          inputRange: [0, 1],
          outputRange: [start, end]
        });
      } else if (typeof start === 'number' && typeof end === 'number') {
        return animatedColor.interpolate({
          inputRange: [0, 1],
          outputRange: [start, end]
        });
      }

      return new Animated.Value(0);
    });
  } // Send all colors as props to enable Animated api to transform it


  _generateColorsProps(interpolatedColors) {
    let props = {};
    interpolatedColors.forEach((interpolateColor, index) => {
      const key = "animatedColor".concat(index);
      props = _.merge(props, {
        [key]: interpolateColor
      });
      return {
        [key]: interpolateColor
      };
    });
    return props;
  }

  render() {
    const _this$props = this.props,
          {
      children
    } = _this$props,
          props = _objectWithoutProperties(_this$props, ["children"]);

    const interpolatedColors = this._getInterpolatedColors();

    const animatedColorsProps = this._generateColorsProps(interpolatedColors);

    const otherProps = _.omit(props, 'animation');

    return /*#__PURE__*/React.createElement(AnimatedLinearGradient, _extends({}, otherProps, animatedColorsProps), /*#__PURE__*/React.createElement(React.Fragment, null, children));
  }

}

_defineProperty(AnimatedGradientTransition, "defaultProps", {
  colors: ['#fff', '#fff'],
  animation: {
    toValue: 1,
    duration: 500,
    easing: Easing.linear,
    useNativeDriver: false
  }
});

export default AnimatedGradientTransition;
//# sourceMappingURL=index.js.map