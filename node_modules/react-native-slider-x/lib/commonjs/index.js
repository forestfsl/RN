"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const TRACK_SIZE = 4;
const THUMB_SIZE = 20;

class Rect {
  constructor(x, y, width, height) {
    _defineProperty(this, "x", void 0);

    _defineProperty(this, "y", void 0);

    _defineProperty(this, "width", void 0);

    _defineProperty(this, "height", void 0);

    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }

  containsPoint(x, y) {
    return x >= this.x && y >= this.y && x <= this.x + this.width && y <= this.y + this.height;
  }

}

const DEFAULT_ANIMATION_CONFIGS = {
  spring: {
    friction: 7,
    tension: 100
  },
  timing: {
    duration: 150,
    easing: _reactNative.Easing.inOut(_reactNative.Easing.ease),
    delay: 0
  }
};
var SizeEnum;

(function (SizeEnum) {
  SizeEnum["_containerSize"] = "_containerSize";
  SizeEnum["_trackSize"] = "_trackSize";
  SizeEnum["_thumbSize"] = "_thumbSize";
})(SizeEnum || (SizeEnum = {}));

var EventEnum;

(function (EventEnum) {
  EventEnum["onSlidingStart"] = "onSlidingStart";
  EventEnum["onValueChange"] = "onValueChange";
  EventEnum["onSlidingComplete"] = "onSlidingComplete";
})(EventEnum || (EventEnum = {}));

class Slider extends _react.PureComponent {
  constructor(_props) {
    super(_props);

    _defineProperty(this, "_panResponder", void 0);

    _defineProperty(this, "_previousLeft", void 0);

    _defineProperty(this, "_containerSize", void 0);

    _defineProperty(this, "_trackSize", void 0);

    _defineProperty(this, "_thumbSize", void 0);

    _defineProperty(this, "currentValue", void 0);

    _defineProperty(this, "_handleStartShouldSetPanResponder", e => // Should we become active when the user presses down on the thumb?
    this._thumbHitTest(e));

    _defineProperty(this, "_handlePanResponderGrant", () =>
    /* e: Object, gestureState: Object */
    {
      this._previousLeft = this._getThumbLeft(this._getCurrentValue());

      this._fireChangeEvent(EventEnum.onSlidingStart);
    });

    _defineProperty(this, "_handlePanResponderMove", (_e, gestureState) => {
      if (this.props.disabled) {
        return;
      }

      this._setCurrentValue(this._getValue(gestureState));

      this._fireChangeEvent(EventEnum.onValueChange);
    });

    _defineProperty(this, "_handlePanResponderEnd", (_e, gestureState) => {
      if (this.props.disabled) {
        return;
      }

      this._setCurrentValue(this._getValue(gestureState));

      this._fireChangeEvent(EventEnum.onSlidingComplete);
    });

    _defineProperty(this, "_measureContainer", layout => {
      this._handleMeasure(SizeEnum._containerSize, layout);
    });

    _defineProperty(this, "_measureTrack", layout => {
      this._handleMeasure(SizeEnum._trackSize, layout);
    });

    _defineProperty(this, "_measureThumb", layout => {
      this._handleMeasure(SizeEnum._thumbSize, layout);
    });

    _defineProperty(this, "_handleMeasure", (storeName, layout) => {
      const {
        width,
        height
      } = layout.nativeEvent.layout;
      const size = {
        width,
        height
      };
      const currentSize = this[storeName];

      if (currentSize && width === currentSize.width && height === currentSize.height) {
        return;
      }

      this[storeName] = size;

      if (this._containerSize && this._trackSize && this._thumbSize) {
        this.setState({
          containerSize: this._containerSize,
          trackSize: this._trackSize,
          thumbSize: this._thumbSize,
          allMeasured: true
        });
      }
    });

    _defineProperty(this, "_getRatio", value => (value - this.props.minimumValue) / (this.props.maximumValue - this.props.minimumValue));

    _defineProperty(this, "_getThumbLeft", value => {
      const nonRtlRatio = this._getRatio(value);

      const ratio = _reactNative.I18nManager.isRTL ? 1 - nonRtlRatio : nonRtlRatio;
      return ratio * (this.state.containerSize.width - this.state.thumbSize.width);
    });

    _defineProperty(this, "_getValue", gestureState => {
      const {
        containerSize,
        thumbSize
      } = this.state;
      const {
        minimumValue,
        maximumValue,
        step
      } = this.props;
      const length = containerSize.width - thumbSize.width;
      const thumbLeft = this._previousLeft + gestureState.dx;
      const nonRtlRatio = thumbLeft / length;
      const ratio = _reactNative.I18nManager.isRTL ? 1 - nonRtlRatio : nonRtlRatio;

      if (step) {
        return Math.max(minimumValue, Math.min(maximumValue, minimumValue + Math.round(ratio * (maximumValue - minimumValue) / step) * step));
      }

      return Math.max(minimumValue, Math.min(maximumValue, ratio * (maximumValue - minimumValue) + minimumValue));
    });

    _defineProperty(this, "_getCurrentValue", () => this.currentValue);

    _defineProperty(this, "_setCurrentValue", value => {
      this.state.value.setValue(value);
    });

    _defineProperty(this, "_setCurrentValueAnimated", value => {
      const animationType = this.props.animationType;
      const animationConfig = Object.assign({}, DEFAULT_ANIMATION_CONFIGS[animationType], this.props.animationConfig, {
        toValue: value
      });

      _reactNative.Animated[animationType](this.state.value, animationConfig).start();
    });

    _defineProperty(this, "_fireChangeEvent", event => {
      const callback = this.props[event];

      if (callback) {
        callback(this._getCurrentValue());
      }
    });

    _defineProperty(this, "_getTouchOverflowSize", () => {
      const state = this.state;
      const props = this.props;
      const size = {
        width: 0,
        height: 0
      };

      if (state.allMeasured === true && props.thumbTouchSize) {
        size.width = Math.max(0, props.thumbTouchSize.width - state.thumbSize.width);
        size.height = Math.max(0, props.thumbTouchSize.height - state.containerSize.height);
      }

      return size;
    });

    _defineProperty(this, "_getTouchOverflowStyle", () => {
      const {
        width,
        height
      } = this._getTouchOverflowSize();

      const touchOverflowStyle = {};

      if (width !== undefined && height !== undefined) {
        const verticalMargin = -height / 2;
        touchOverflowStyle.marginTop = verticalMargin;
        touchOverflowStyle.marginBottom = verticalMargin;
        const horizontalMargin = -width / 2;
        touchOverflowStyle.marginLeft = horizontalMargin;
        touchOverflowStyle.marginRight = horizontalMargin;
      }

      if (this.props.debugTouchArea === true) {
        touchOverflowStyle.backgroundColor = 'orange';
        touchOverflowStyle.opacity = 0.5;
      }

      return touchOverflowStyle;
    });

    _defineProperty(this, "_thumbHitTest", e => {
      const nativeEvent = e.nativeEvent;

      const thumbTouchRect = this._getThumbTouchRect();

      return thumbTouchRect.containsPoint(nativeEvent.locationX, nativeEvent.locationY);
    });

    _defineProperty(this, "_getThumbTouchRect", () => {
      const state = this.state;
      const {
        thumbTouchSize
      } = this.props;

      const touchOverflowSize = this._getTouchOverflowSize();

      return new Rect(touchOverflowSize.width / 2 + this._getThumbLeft(this._getCurrentValue()) + (state.thumbSize.width - thumbTouchSize.width) / 2, touchOverflowSize.height / 2 + (state.containerSize.height - thumbTouchSize.height) / 2, thumbTouchSize.width, thumbTouchSize.height);
    });

    _defineProperty(this, "_renderDebugThumbTouchRect", thumbLeft => {
      const thumbTouchRect = this._getThumbTouchRect();

      const positionStyle = {
        left: thumbLeft,
        top: thumbTouchRect.y,
        width: thumbTouchRect.width,
        height: thumbTouchRect.height
      };
      return /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, {
        style: [defaultStyles.debugThumbTouchArea, positionStyle],
        pointerEvents: "none"
      });
    });

    _defineProperty(this, "_renderThumbImage", () => {
      const {
        thumbImage,
        renderThumb
      } = this.props;

      if (renderThumb) {
        return renderThumb();
      }

      if (!thumbImage) return;
      return /*#__PURE__*/_react.default.createElement(_reactNative.Image, {
        source: thumbImage
      });
    });

    this.state = {
      containerSize: {
        width: 0,
        height: 0
      },
      trackSize: {
        width: 0,
        height: 0
      },
      thumbSize: {
        width: 0,
        height: 0
      },
      allMeasured: false,
      value: new _reactNative.Animated.Value(_props.value || 0)
    };
    this._panResponder = _reactNative.PanResponder.create({
      onStartShouldSetPanResponder: this._handleStartShouldSetPanResponder,
      onMoveShouldSetPanResponder: this._handleMoveShouldSetPanResponder,
      onPanResponderGrant: this._handlePanResponderGrant,
      onPanResponderMove: this._handlePanResponderMove,
      onPanResponderRelease: this._handlePanResponderEnd,
      onPanResponderTerminationRequest: this._handlePanResponderRequestEnd,
      onPanResponderTerminate: this._handlePanResponderEnd
    });
    this._previousLeft = 0;
    this.currentValue = 0;
    this.state.value.addListener(({
      value
    }) => {
      this.currentValue = value;
    });
  }

  getParams(o, name) {
    return o[name];
  }

  componentDidUpdate(prevProps) {
    const newValue = this.props.value || 0;

    if (prevProps.value !== newValue) {
      if (this.props.animateTransitions) {
        this._setCurrentValueAnimated(newValue);
      } else {
        this._setCurrentValue(newValue);
      }
    }
  }

  render() {
    const _this$props = this.props,
          {
      minimumValue = 0,
      maximumValue = 100,
      minimumTrackTintColor,
      maximumTrackTintColor,
      thumbTintColor,
      thumbImage,
      styles,
      style,
      trackStyle,
      thumbStyle,
      debugTouchArea,
      onValueChange,
      thumbTouchSize,
      animationType,
      animateTransitions
    } = _this$props,
          other = _objectWithoutProperties(_this$props, ["minimumValue", "maximumValue", "minimumTrackTintColor", "maximumTrackTintColor", "thumbTintColor", "thumbImage", "styles", "style", "trackStyle", "thumbStyle", "debugTouchArea", "onValueChange", "thumbTouchSize", "animationType", "animateTransitions"]);

    const {
      value,
      containerSize,
      thumbSize,
      allMeasured
    } = this.state;
    const mainStyles = Object.assign({}, styles, defaultStyles);
    const thumbLeft = value.interpolate({
      inputRange: [minimumValue, maximumValue],
      outputRange: _reactNative.I18nManager.isRTL ? [0, -(containerSize.width - thumbSize.width)] : [0, containerSize.width - thumbSize.width] // extrapolate: 'clamp',

    });
    const minimumTrackWidth = value.interpolate({
      inputRange: [minimumValue, maximumValue],
      outputRange: [0, containerSize.width - thumbSize.width] // extrapolate: 'clamp',

    });
    const valueVisibleStyle = {};

    if (!allMeasured) {
      valueVisibleStyle.opacity = 0;
    }

    const minimumTrackStyle = _objectSpread({
      position: 'absolute',
      width: _reactNative.Animated.add(minimumTrackWidth, thumbSize.width / 2),
      backgroundColor: minimumTrackTintColor
    }, valueVisibleStyle);

    const touchOverflowStyle = this._getTouchOverflowStyle();

    return /*#__PURE__*/_react.default.createElement(_reactNative.View, _extends({}, other, {
      style: [mainStyles.container, style],
      onLayout: this._measureContainer
    }), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
      style: [{
        backgroundColor: maximumTrackTintColor
      }, mainStyles.track, trackStyle],
      renderToHardwareTextureAndroid: true,
      onLayout: this._measureTrack
    }), /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, {
      renderToHardwareTextureAndroid: true,
      style: [mainStyles.track, trackStyle, minimumTrackStyle]
    }), /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, {
      onLayout: this._measureThumb,
      renderToHardwareTextureAndroid: true,
      style: [{
        backgroundColor: thumbTintColor
      }, mainStyles.thumb, thumbStyle, _objectSpread({
        transform: [{
          translateX: thumbLeft
        }, {
          translateY: 0
        }]
      }, valueVisibleStyle)]
    }, this._renderThumbImage()), /*#__PURE__*/_react.default.createElement(_reactNative.View, _extends({
      renderToHardwareTextureAndroid: true,
      style: [defaultStyles.touchArea, touchOverflowStyle]
    }, this._panResponder.panHandlers), debugTouchArea === true && this._renderDebugThumbTouchRect(minimumTrackWidth)));
  }

  _getPropsForComponentUpdate(props) {
    const {
      value,
      onValueChange,
      onSlidingStart,
      onSlidingComplete,
      style,
      trackStyle,
      thumbStyle
    } = props,
          otherProps = _objectWithoutProperties(props, ["value", "onValueChange", "onSlidingStart", "onSlidingComplete", "style", "trackStyle", "thumbStyle"]);

    return otherProps;
  }

  _handleMoveShouldSetPanResponder() {
    // Should we become active when the user moves a touch over the thumb?
    return false;
  }

  _handlePanResponderRequestEnd() {
    // Should we allow another component to take over this pan?
    return false;
  }

}

exports.default = Slider;

_defineProperty(Slider, "defaultProps", {
  value: 0,
  minimumValue: 0,
  maximumValue: 1,
  step: 0,
  minimumTrackTintColor: '#3f3f3f',
  maximumTrackTintColor: '#b3b3b3',
  thumbTintColor: '#343434',
  thumbTouchSize: {
    width: 40,
    height: 40
  },
  debugTouchArea: false,
  animationType: 'timing',
  onValueChange: () => {}
});

const defaultStyles = _reactNative.StyleSheet.create({
  container: {
    height: 40,
    justifyContent: 'center'
  },
  track: {
    height: TRACK_SIZE,
    borderRadius: TRACK_SIZE / 2
  },
  thumb: {
    position: 'absolute',
    width: THUMB_SIZE,
    height: THUMB_SIZE,
    borderRadius: THUMB_SIZE / 2
  },
  touchArea: {
    position: 'absolute',
    backgroundColor: 'transparent',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  },
  debugThumbTouchArea: {
    position: 'absolute',
    backgroundColor: 'green',
    opacity: 0.5
  }
});
//# sourceMappingURL=index.js.map